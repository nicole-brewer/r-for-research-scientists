[
["index.html", "R for Research Scientists Preamble", " R for Research Scientists Nicole Brewer 2020-02-05 Preamble Who is this book for? There are already many great tutorials out there for building packages in R, but they are generally too comprehensive, and cater to project administrators. This book is intended for researchers who contriubute code to an R project, and leaves out details irrelevant to this audience. If you are the administrator for you project or you just want to know more about what’s going on behind the hood, each section begins by explaining the why of standard practices, and includes resources that explain how to implement them. What you won’t learn. How to program in R. What will you learn? How to contribute to a well structured project. Why this worth your precious time? Reading this book will save you from more headaches and time-wasters than you can imagine, especially as your project grows in size and complexity. "],
["git.html", "1 Git and Github 1.1 Git in RStudio 1.2 Git Workflow from a Fork", " 1 Git and Github The what and why of version control (specific to R!) can be found here 1.1 Git in RStudio There is a “git” tab in RStudio, but it can’t perform simple operations required to develop a project from a fork, so you likely want to start using the terminal for all of your git needs. If you are a visual person, there are many flavors of git guis for download( (which can be found here) that have graphical history viewers that show color coded history trees. Figure 1: Gitk’s interface (Git 2020) Gitk (shown above) and git-gui come with a standard Git install. If you wish to make a commit with a gui, use the command git gui and if you wish to view the history tree, execute gitk --all in your terminal. 1.1.1 Setting Up Remotes for the First Time Create a fork on GitHub. A fork is a static copy of someone else’s Github repository. A remote repository is the version that is stored on a GitHub server (as opposed to your personal laptop or local machine), and is the version available for viewing on github.com. An upstream repository is the shared version of the project that you are contributing to. # create a local copy (clone) of your fork git clone https://github.rcac.purdue.edu/&lt;YOUR_USERNAME&gt;/SuperPower.git # remote origin is your own personal fork as it lives on GitHub git remote set-url origin https://github.rcac.purdue.edu/&lt;YOUR_USERNAME&gt;/SuperPower.git # remote upstream is the parent repository as it lives on GitHub git remote set-url upstream https://github.rcac.purdue.edu/ScientificSolutions/SuperPower.git # list remotes git remote -v 1.2 Git Workflow from a Fork Inspired by @Chaser324’s Gist. 1.2.1 Merge upstream changes into your own master branch This should be nontrivial if you committed and pushed the last time you coded. # Fetch from upstream remote git fetch upstream # Checkout your master branch and merge upstream git checkout master git merge upstream/master 1.2.2 Create a branch to work on a new feature or bugfix # Checkout the master branch - you want your new branch to come from master git checkout master # Create a new branch named newfeature (give your branch its own simple informative name) git branch newfeature # Switch to your new branch git checkout newfeature 1.2.3 Use the Repeated Amend strategy to develop your feature branch This strategy comes from Chapter 24 of Happy Git with R. I highly suggest that you read the whole thing yourself. The idea of a repeated amend is that you can have a version of your code to fall back on (with a git reset --hard) that is more recent than your last commit. Imagine, you don’t want to make a tiny commit for every trivial change, but at some point you are far through your next commit, and things start breaking. A repeated amend is how we prevent tiny commits, and provide ourselves with a fail safe at every step of your code that still runs. # make a few changes to the code and test to make sure nothing is broken # commit so we have something to revert back to if need be git commit -m &quot;The name of the thing I want to accomplish in the completed commit&quot; # make a few more changes # instead of making another giant commit, we amend our last one with the new changes git commit --amend # --no-edit if you don&#39;t need to change the message # we continue this process until we want to start a new commit, by not using --amend 1.2.3.1 Incorperate upstream changes Just make sure you’re incorperating upstream changes to origin master. Then you can pull from master to your feature branch. git fetch upstream git checkout master git merge upstream/master git checkout newfeature git pull --rebase origin master This works as long as the upstream changes don’t overlap with any of the changes you have made. If this doesn’t work for you there are other, more complicated ways to deal with this. Note: a rebase rewrites your history so that your new commits are shifted to the top of the master branch, as shown below. Figure 2: Rebase of feature branch (Tutorials and Atlassian Git Tutorial 2020) 1.2.4 Push changes to GitHub and create pull request "],
["pack.html", "2 Packages 2.1 Install Development Tools 2.2 Rules and Best Practices: 2.3 Building the package", " 2 Packages R packages are the vehicle for distributing working code to other users and their machines. Building a package turns a developer’s human readable code into binary that can be transfered to another user’s computer, and then installed so that package becomes available to the user. 2.1 Install Development Tools Buiding an R package requires extra development software that does not come with R or RStudio. 2.1.1 Mac: XCode In your terminal, execute xcode-select --install, and if you are prompted to install command line developer tools, select “Install” and “Agree”. 2.1.2 Windows: Rtools Download and run the recommended Rtools.exe file from https://cran.r-project.org/bin/windows/Rtools/ with the default selections. 2.1.3 Linux: R development tools package Install the R development tools package corresponding to your system. 2.1.4 Verify Success in RStudio Console library(devtools) has_devel() 2.2 Rules and Best Practices: All external packages you use inside your package should be listed under the Imports: field in the DESCRIPTION file. This is what makes them available to to your code. Use explicit package::function notation when calling a function from another package If you are using a particular function a lot, you may add @importFrom package function to the roxygen block to avoid using the above explicit notation If you are writing a function to be used by a user of the package, you have to export it. You can do this by placing @export in the roxygen block which is discussed in ?? 2.3 Building the package 2.3.1 When? You should always clean and build the package (and resolve any errors or warnings) before making a commit. 2.3.2 Clean In the RStudio Toolbar, select “Build” &gt;&gt; “Clean”. This removes unneccesssary files that were created from a previous build. 2.3.3 Build R CMD check in the terminal, devtools::check() in the console, and Ctrl/Cmd + Shift + E in RStudio all deploy a function that checks your package for common problems and makes sure a package includes everything in needs to play well with others upon distribution. Errors and warnings produced by the check() funciton should be resolved before every commit. This workflow comes from the book R packages (Wickham and Bryan 2019): Run the devtools::check() function Fix the first error or warning Repeat steps (1) and (2) until all errors and warnings are resolved. Now in order to be able to use the package, use the devtools::install() function or Ctrl/Cmd + Shift + B to load the current version of the package into RStudio. "],
["test.html", "3 Unit Testing 3.1 Test Scripts 3.2 An Example Test 3.3 Expectations 3.4 Testing Workflow", " 3 Unit Testing Likely as not, you have already written scripts that demonstrate that your script runs and produces a desired results. Unit testing, via the testthat package (Wickham 2011), formalizes this process and automates many of these scripts at once to make running a comprehensive test set easy to do. Read up about testing and automated checking 3.1 Test Scripts Each time you write a user-facing or non-trivial function, you should write a test script that verifies that the function returns the result you expected in all individual cases. These test files live in tests/testthat/. The file name must start with “test” and it should indicate which function or functionality is being tested. 3.2 An Example Test test_that(&quot;multiplication works&quot;, { actual = 2 * 2 expected = 4 expect_equal(actual, expected) }) 3.3 Expectations Expect functions are those at the end of test each test case that allow you to check the output of your function against what you expect. There are many kinds of these functions, the most common being expect_equal(). If need be, there are more complicated ways to express expectation such as expect_lt() that passes when the returned value is less than the specified value, or expect_error() that expects an error to be thrown instead of a return value. A comprehensive list can be found here. 3.4 Testing Workflow Create a new functionality. Write a series of tests in a new file to verify your function behaves the way you expect in every scenario, including edge cases, with parameters like 0, null, and minimum or maximum possible input values. Load the edits you made and test the package with devtools::test(). Modify your code to fix failing test cases. Repeat until all tests pass. "],
["doc.html", "4 Documentation 4.1 How roxygen Works 4.2 R Documentation (Rd) Format 4.3 Exports", " 4 Documentation 4.1 How roxygen Works When you create documentation, you want it to be available in several forms: an imformative comment block above each function, something that can be accessed by the help() function, something that can be rendered on a website, and perhaps a PDF. roxygen is convenient, because it automatically converts a comment block into all these other formats. Here is an examle of a function with roxygen documentation block: #&#39; Add together two numbers. #&#39; #&#39; @param x A number. #&#39; @param y A number. #&#39; @return The sum of \\code{x} and \\code{y}. #&#39; @examples #&#39; add(1, 1) #&#39; add(10, 1) add &lt;- function(x, y) { x + y } You may notice the single quote after the hashtag ( #' ); this is to distinguish between a regular comment and an roxygen comment. 4.2 R Documentation (Rd) Format You may also notice the \\code{} formatting command. There are many of these commands that are in R documentation markup language. They are useful because they help render the text correctly in the variety of formats previously mentioned. Tags such as @param above breaks up each block into distince sections. Three of these tags may be implied and excluded; for example the title section in the above example is shown as the first sentence in the block, although it could have been explicitely demarkated with a @title tag. The second paragraph is always the description, and any subsequent unmarked paragraphs go into the details section. 4.2.1 Generate Roxygen Skeleton Place your cursor on a fuction you haven’t yet made documentation for. In RStudio menu, select “Code” -&gt; “Insert Roxygen Skeleton”. 4.3 Exports Any functions in your package you want your user to have access to need to be exported. This can be done to an object or function by adding @export to its roxygen block. "],
["putting-it-all-together.html", "5 Putting It All Together 5.1 The Workflow 5.2 Contending with Upstream Changes", " 5 Putting It All Together 5.1 The Workflow 5.1.1 Before we start coding, let’s make sure were up to date. # Fetch from upstream remote git fetch upstream # Checkout your master branch and merge upstream git checkout master git merge upstream/master 5.1.2 Create a branch to work on a new feature or bugfix # Checkout the master branch - you want your new branch to come from master git checkout master # Create a new branch named newfeature (give your branch its own simple informative name) git branch newfeature # Switch to your new branch git checkout newfeature 5.1.3 Load the devtools library # We use devtools a lot, and if we don&#39;t wan&#39;t to use the long form function call dev_tools::load_all() # we can make it available in our console with library(devtools) # so next time we only have to type load_all() 5.1.4 Abide by the Repeaded Amend strategy We should make commits often. We should make amends even more often, so if our code ever breaks in horrible ways, we can easily discard our work since the last amend with git reset --hard First: Make a small change to your code. Next: # When you want to test the changes you&#39;ve made by running code, first execute ... load_all() # ... in your console. This function **simulates** that your updated code has been added to your package # so you can play aroud with it without actually building the changes into all of your package files. # This means you can load_all (as opposed to build) at any time in development without having to # rebuild after correcting a mistake # [VERIFY YOUR UPDATED CODE WORKS (by running code or test cases)] commit add &lt;files&gt; &lt;you&gt; &lt;just&gt; &lt;updated&gt; # This next bit goes one of two ways # 1. If you haven&#39;t created a new commit yet... commit -m &quot;Describe the feature or bugfix&quot; # 2. If you want to add more changes on top of a commit you&#39;ve already started... commit --amend Finally: Repeat until you’ve correctly implemented a new functionality. 5.1.5 Integrate Changes with the Package The check() function does three things for us: it updates our roxygen documentation, it runs our testthat test files, and it checks for a bunch of things that make sure we’ve implemented our code well. Run the devtools::check(cleanup=TRUE) function Fix the first error or warning Repeat steps (1) and (2) until all errors and warnings are resolved. git commit --amend one last time. Make sure to include all those files produced or updated by the check function, even if you didn’t write it yourself. 5.1.6 Incorperate Upstream Changes Before you create a pull request, you’ll want to make sure you’ve incorperated upstream changes into your feature branch. # merge upstream changes into master git fetch upstream git checkout master git merge upstream/master # pull those changes from master into your feature git checkout newfeature git pull --rebase origin master 5.1.7 Congratulations! You have successfully create a feature, and you may submit a pull request :blush: 5.2 Contending with Upstream Changes "],
["references.html", "References", " References Git. 2020. “Gitk.” https://git-scm.com/book/en/v2/images/gitk.png. Tutorials, Git, and Training | Atlassian Git Tutorial. 2020. “Git Rebase: Branch onto Master.” https://wac-cdn.atlassian.com/dam/jcr:e4a40899-636b-4988-9774-eaa8a440575b/02.svg?cdnVersion=752. Wickham, Hadley. 2011. “Testthat: Get Started with Testing.” The R Journal 3: 5–10. https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf. Wickham, Hadley, and Jennifer Bryan. 2019. R Packages. https://r-pkgs.org/. "]
]
