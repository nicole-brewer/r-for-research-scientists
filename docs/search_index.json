[
["index.html", "Publications in RStudio Preamble", " Publications in RStudio Nicole Brewer 2020-03-10 Preamble Who is this book for? There are already many great tutorials out there for building packages in R, but they are generally too comprehensive, and cater to project administrators. This book is intended for researchers who contriubute code to an R project, and leaves out details irrelevant to this audience. If you are the administrator for you project or you just want to know more about what’s going on behind the hood, each section begins by explaining the why of standard practices, and includes resources that explain how to implement them. What you won’t learn. How to program in R. What will you learn? How to contribute to a well structured project. Why this worth your precious time? Reading this book will save you from more headaches and time-wasters than you can imagine, especially as your project grows in size and complexity. "],
["r-language-and-environment.html", "Chapter: 1 R Language and Environment 1.1 Strengths 1.2 Making Up for Weaknesses with Python", " Chapter: 1 R Language and Environment According to it’s website (R Core Team 2019), R is a language and environment for statistical computing and graphics. While R can technically be used to create complicated software, by this definition we know that this is not the language’s primary purpose. On the other hand, R and RStudio support all stages of development in a single application window with four panes, including visualization, building, documentation, unit testing, file navigation, add-ons, environment variables and more. R is highly specialized which naturally engenders compelling strengths and weaknesses. 1.1 Strengths 1.1.1 Extensibility A package is an R project that can be shared and installed by other users. Installing packages extremely easy in R; you can even install a package straight from a GitHub repository link. Because of this, it’s highly extesible, meaning that it’s easy to incorperate other packages into your own and extend the functionality of to original package. R has been around over 20 years, and because packages are so easy to create and share, there is typically already a package that has the statistical functionality you may need. Thus one good reason to choose R is that your community already has a well established set of packages that suite most needs. 1.1.2 Visualization R comes with data analysis graphics baked-in and come with with diverse display options including on-screen and hardcopy. 1.1.3 Documentation and Publication R is fully integrated with well-developed publishing tools that are discussed in [Chapter 7]. 1.1.4 Tabular Data Tidyverse is a well-developed and expanding set of packages designed for data science or in any place you may want to use sets of rectangular data. &gt; In brief, when your data is tidy, each column is a variable, and each row is an observation. Tidy data is important because the consistent structure lets you focus your struggle on questions about the data, not fighting to get the data into the right form for different functions. (???) 1.2 Making Up for Weaknesses with Python R simply isn’t a language designed for the development of complex software or applications. While R does technically support object oriented programming, there are three kinds of objects: S3, R6, and S4. Choosing the right type and knowing the best way to implement it is difficult, and has a high buy-in. Python on the other hand is known for it’s simplistic syntax and having set of “pythonic” implementation standards that keep code easy to read. A lack of stack trace error messages make bugging multiple files and functioins in R is confusing and arduous. Complicated data types make implementing input validation difficult. Given all this, the age old question “should I use R or Python?” is poorly posed question. Rather, we should write each piece of the project in whatever language suits our needs best, and then ask “how do I best integrate my R and Python code”? 1.2.1 Calling Python from R If you are an R developer that uses Python for some of your work or a member of data science team that uses both languages, you can use the reticulate package to interface with Python(???). 1.2.2 Calling R from Python If you are simply performing statistical or data analysis it may be best to stick with R, but if the project is a fully-fleged application, you may want to scaffold the project with Python. rpy2 establishes an interface between both languages so a developer may benefit from the libraries of one language while working in the other (???). References "],
["git.html", "Chapter: 2 Git and Github 2.1 Git in RStudio 2.2 Git Workflow from a Fork", " Chapter: 2 Git and Github The what and why of version control (specific to R!) can be found here 2.1 Git in RStudio There is a “git” tab in RStudio, but it can’t perform simple operations required to develop a project from a fork, so you likely want to start using the terminal for all of your git needs. If you are a visual person, there are many flavors of git guis for download( (which can be found here) that have graphical history viewers that show color coded history trees. Figure 2.1: Gitk’s interface (Git 2020) Gitk (shown above) and git-gui come with a standard Git install. If you wish to make a commit with a gui, use the command git gui and if you wish to view the history tree, execute gitk --all in your terminal. 2.1.1 Setting Up Remotes for the First Time Create a fork on GitHub. A fork is a static copy of someone else’s Github repository. A remote repository is the version that is stored on a GitHub server (as opposed to your personal laptop or local machine), and is the version available for viewing on github.com. An upstream repository is the shared version of the project that you are contributing to. # create a local copy (clone) of your fork git clone https://github.rcac.purdue.edu/&lt;YOUR_USERNAME&gt;/SuperPower.git # remote origin is your own personal fork as it lives on GitHub git remote set-url origin https://github.rcac.purdue.edu/&lt;YOUR_USERNAME&gt;/SuperPower.git # remote upstream is the parent repository as it lives on GitHub git remote add upstream https://github.rcac.purdue.edu/ScientificSolutions/SuperPower.git # list remotes git remote -v 2.2 Git Workflow from a Fork Inspired by @Chaser324’s Gist. 2.2.1 Merge upstream changes into your own master branch This should be nontrivial if you committed and pushed the last time you coded. # Fetch from upstream remote git fetch upstream # Checkout your master branch and merge upstream git checkout master git merge upstream/master 2.2.2 Create a branch to work on a new feature or bugfix # Checkout the master branch - you want your new branch to come from master git checkout master # Create a new branch named newfeature (give your branch its own simple informative name) git branch newfeature # Switch to your new branch git checkout newfeature 2.2.3 Use the Repeated Amend strategy to develop your feature branch This strategy comes from Chapter 24 of Happy Git with R. I highly suggest that you read the whole thing yourself. The idea of a repeated amend is that you can have a version of your code to fall back on (with a git reset --hard) that is more recent than your last commit. Imagine, you don’t want to make a tiny commit for every trivial change, but at some point you are far through your next commit, and things start breaking. A repeated amend is how we prevent tiny commits, and provide ourselves with a fail safe at every step of your code that still runs. # make a few changes to the code and test to make sure nothing is broken # commit so we have something to revert back to if need be git commit -m &quot;The name of the thing I want to accomplish in the completed commit&quot; # make a few more changes # instead of making another giant commit, we amend our last one with the new changes git commit --amend # --no-edit if you don&#39;t need to change the message # we continue this process until we want to start a new commit, by not using --amend 2.2.3.1 Incorperate upstream changes Just make sure you’re incorperating upstream changes to origin master. Then you can pull from master to your feature branch. git fetch upstream git checkout master git merge upstream/master git checkout newfeature git pull --rebase origin master This works as long as the upstream changes don’t overlap with any of the changes you have made. If this doesn’t work for you there are other, more complicated ways to deal with this. Note: a rebase rewrites your history so that your new commits are shifted to the top of the master branch, as shown below. Figure 2.2: Rebase of feature branch (Tutorials and Atlassian Git Tutorial 2020) 2.2.4 Push changes to GitHub and create pull request References "],
["pack.html", "Chapter: 3 Packages 3.1 Install Development Tools 3.2 Rules and Best Practices: 3.3 Building the package", " Chapter: 3 Packages R packages are the vehicle for distributing working code to other users and their machines. Building a package turns a developer’s human readable code into binary that can be transfered to another user’s computer, and then installed so that package becomes available to the user. 3.1 Install Development Tools Buiding an R package requires extra development software that does not come with R or RStudio. 3.1.1 Mac: XCode In your terminal, execute xcode-select --install, and if you are prompted to install command line developer tools, select “Install” and “Agree”. 3.1.2 Windows: Rtools Download and run the recommended Rtools.exe file from https://cran.r-project.org/bin/windows/Rtools/ with the default selections. 3.1.3 Linux: R development tools package Install the R development tools package corresponding to your system. 3.1.4 Verify Success in RStudio Console library(devtools) has_devel() 3.2 Rules and Best Practices: All external packages you use inside your package should be listed under the Imports: field in the DESCRIPTION file. This is what makes them available to to your code. Use explicit package::function notation when calling a function from another package If you are using a particular function a lot, you may add @importFrom package function to the roxygen block to avoid using the above explicit notation If you are writing a function to be used by a user of the package, you have to export it. You can do this by placing @export in the roxygen block which is discussed in 5 3.3 Building the package 3.3.1 When? You should always clean and build the package (and resolve any errors or warnings) before making a commit. 3.3.2 Clean In the RStudio Toolbar, select “Build” &gt;&gt; “Clean”. This removes unneccesssary files that were created from a previous build. 3.3.3 Build R CMD check in the terminal, devtools::check() in the console, and Ctrl/Cmd + Shift + E in RStudio all deploy a function that checks your package for common problems and makes sure a package includes everything in needs to play well with others upon distribution. Errors and warnings produced by the check() funciton should be resolved before every commit. This workflow comes from the book R packages (Wickham and Bryan 2019): Run the devtools::check() function Fix the first error or warning Repeat steps (1) and (2) until all errors and warnings are resolved. Now in order to be able to use the package, use the devtools::install() function or Ctrl/Cmd + Shift + B to load the current version of the package into RStudio. References "],
["test.html", "Chapter: 4 Unit Testing 4.1 Test Scripts 4.2 An Example Test 4.3 Expectations 4.4 Testing Workflow", " Chapter: 4 Unit Testing Likely as not, you have already written scripts that demonstrate that your script runs and produces a desired results. Unit testing, via the testthat package (Wickham 2011), formalizes this process and automates many of these scripts at once to make running a comprehensive test set easy to do. Read up about testing and automated checking 4.1 Test Scripts Each time you write a user-facing or non-trivial function, you should write a test script that verifies that the function returns the result you expected in all individual cases. These test files live in tests/testthat/. The file name must start with “test” and it should indicate which function or functionality is being tested. 4.2 An Example Test test_that(&quot;multiplication works&quot;, { actual = 2 * 2 expected = 4 expect_equal(actual, expected) }) 4.3 Expectations Expect functions are those at the end of test each test case that allow you to check the output of your function against what you expect. There are many kinds of these functions, the most common being expect_equal(). If need be, there are more complicated ways to express expectation such as expect_lt() that passes when the returned value is less than the specified value, or expect_error() that expects an error to be thrown instead of a return value. A comprehensive list can be found here. 4.4 Testing Workflow Create a new functionality. Write a series of tests in a new file to verify your function behaves the way you expect in every scenario, including edge cases, with parameters like 0, null, and minimum or maximum possible input values. Load the edits you made and test the package with devtools::test(). Modify your code to fix failing test cases. Repeat until all tests pass. References "],
["doc.html", "Chapter: 5 Documentation 5.1 How roxygen Works 5.2 R Documentation (Rd) Format 5.3 Exports", " Chapter: 5 Documentation 5.1 How roxygen Works When you create documentation, you want it to be available in several forms: an imformative comment block above each function, something that can be accessed by the help() function, something that can be rendered on a website, and perhaps a PDF. roxygen is convenient, because it automatically converts a comment block into all these other formats. Here is an examle of a function with roxygen documentation block: #&#39; Add together two numbers. #&#39; #&#39; @param x A number. #&#39; @param y A number. #&#39; @return The sum of \\code{x} and \\code{y}. #&#39; @examples #&#39; add(1, 1) #&#39; add(10, 1) add &lt;- function(x, y) { x + y } You may notice the single quote after the hashtag ( #' ); this is to distinguish between a regular comment and an roxygen comment. 5.2 R Documentation (Rd) Format You may also notice the \\code{} formatting command. There are many of these commands that are in R documentation markup language. They are useful because they help render the text correctly in the variety of formats previously mentioned. Tags such as @param above breaks up each block into distince sections. Three of these tags may be implied and excluded; for example the title section in the above example is shown as the first sentence in the block, although it could have been explicitely demarkated with a @title tag. The second paragraph is always the description, and any subsequent unmarked paragraphs go into the details section. 5.2.1 Generate Roxygen Skeleton Place your cursor on a fuction you haven’t yet made documentation for. In RStudio menu, select “Code” -&gt; “Insert Roxygen Skeleton”. 5.3 Exports Any functions in your package you want your user to have access to need to be exported. This can be done to an object or function by adding @export to its roxygen block. "],
["putting-it-all-together.html", "Chapter: 6 Putting It All Together 6.1 The Workflow 6.2 Contending with Upstream Changes", " Chapter: 6 Putting It All Together 6.1 The Workflow 6.1.1 Before we start coding, let’s make sure were up to date. # Fetch from upstream remote git fetch upstream # Checkout your master branch and merge upstream git checkout master git merge upstream/master 6.1.2 Create a branch to work on a new feature or bugfix # Checkout the master branch - you want your new branch to come from master git checkout master # Create a new branch named newfeature (give your branch its own simple informative name) git branch newfeature # Switch to your new branch git checkout newfeature 6.1.3 Load the devtools library # We use devtools a lot, and if we don&#39;t wan&#39;t to use the long form function call dev_tools::load_all() # we can make it available in our console with library(devtools) # so next time we only have to type load_all() 6.1.4 Abide by the Repeaded Amend strategy We should make commits often. We should make amends even more often, so if our code ever breaks in horrible ways, we can easily discard our work since the last amend with git reset --hard First: Make a small change to your code. Next: # When you want to test the changes you&#39;ve made by running code, first execute ... load_all() # ... in your console. This function **simulates** that your updated code has been added to your package # so you can play aroud with it without actually building the changes into all of your package files. # This means you can load_all (as opposed to build) at any time in development without having to # rebuild after correcting a mistake # [VERIFY YOUR UPDATED CODE WORKS (by running code or test cases)] commit add &lt;files&gt; &lt;you&gt; &lt;just&gt; &lt;updated&gt; # This next bit goes one of two ways # 1. If you haven&#39;t created a new commit yet... commit -m &quot;Describe the feature or bugfix&quot; # 2. If you want to add more changes on top of a commit you&#39;ve already started... commit --amend Finally: Repeat until you’ve correctly implemented a new functionality. 6.1.5 Integrate Changes with the Package The check() function does three things for us: it updates our roxygen documentation, it runs our testthat test files, and it checks for a bunch of things that make sure we’ve implemented our code well. Run the devtools::check(cleanup=TRUE) function Fix the first error or warning Repeat steps (1) and (2) until all errors and warnings are resolved. git commit --amend one last time. Make sure to include all those files produced or updated by the check function, even if you didn’t write it yourself. 6.1.6 Incorperate Upstream Changes Before you create a pull request, you’ll want to make sure you’ve incorperated upstream changes into your feature branch. # merge upstream changes into master git fetch upstream git checkout master git merge upstream/master # pull those changes from master into your feature git checkout newfeature git pull --rebase origin master 6.1.7 Congratulations! You have successfully create a feature, and you may submit a pull request :blush: 6.2 Contending with Upstream Changes "],
["publications.html", "Chapter: 7 Publications 7.1 R Markdown and knitr 7.2 Vingettes 7.3 Bookdown 7.4 Citation Managment", " Chapter: 7 Publications 7.1 R Markdown and knitr Markdown is a simple, human-readable, language designed to be easily converted into other more practical markup languages such as HTML. A markup language is one where the syntactic elements have implied meaning in terms of how they are organized and displayed. In HTML, these elements are defined with tags, where in Markdown, they are defined by visually friendly syntax. R Markdown is an extension of this widely used markup language, but the rmarkdown package helps users create dynamic analysis documents that combine code, rendered output (such as figures), and prose (Allaire et al. 2020). Specifically, knitr is the engine that makes it possible to combine runnable text and code in a readable document. R Markdown documents can easily be converted to manifold other formats such as HTML, PowerPoint presentations, Word documents, well formatted PDFs, interactive notebooks (compare to Jupyter) and a few others specific to R which we discuss below. The Definitive Guide to R Markdown(Xie, Allaire, and Grolemund 2018) can be found here. 7.2 Vingettes Vingettes, or so-called “long-form documentation”, is the best way to provide end-to-end examples of your package code to a user. More information about writing vingettes can be found in Chapter 9 of R Packages (Wickham and Bryan 2019). 7.3 Bookdown 7.4 Citation Managment 7.4.1 Zotero 7.4.2 Better BibTeX 7.4.3 citr References "],
["references.html", "References", " References Allaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for R. https://CRAN.R-project.org/package=rmarkdown. Git. 2020. “Gitk.” https://git-scm.com/book/en/v2/images/gitk.png. R Core Team. 2019. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Tutorials, Git, and Training | Atlassian Git Tutorial. 2020. “Git Rebase: Branch onto Master.” https://wac-cdn.atlassian.com/dam/jcr:e4a40899-636b-4988-9774-eaa8a440575b/02.svg?cdnVersion=752. Wickham, Hadley. 2011. “Testthat: Get Started with Testing.” The R Journal 3: 5–10. https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf. Wickham, Hadley, and Jennifer Bryan. 2019. R Packages. https://r-pkgs.org/. Xie, Yihui, J. J. Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown. "]
]
